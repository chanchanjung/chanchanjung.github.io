# Sort

정렬은 특정 기준을 가지고 순서대로 재배치하는 것이다.

정렬의 종류에는 여러가지가 있지만 알고리즘에 주로 사용되는 6가지 정렬에 대해 알아보려고 한다.

## 버블 정렬(Bubble Sort)

버블 정렬은 서로 인접한 두 원소를 비교하여 순서대로 정렬한다.<br>
매번 처음부터 시작하여 비교하고 끝에서부터 앞으로 채워나가는 방법이다.<br>
숫자를 작은 순으로 정렬하는 경우, 1번 숫자와 2번 숫자를 비교하여 정렬하고, 
2번 숫자와 3번 숫자를 비교하여 정렬함으로서 가장 큰 값부터 자리를 찾아가는 것이다.

정렬 중 가장 쉽지만, 시간복잡도가 O(n^2) 으로 좋지 않아 실제로 사용하지 않는다.

예를 들어

                                  1, 5, 3, 4, 2 

5개의 숫자를 오름차순으로 정렬하는 경우, 먼저 1과 5를 비교하면 5가 더 크기 때문에 자리를 바꾸지 않는다. 

그 다음으론 5와 3을 비교하여 자리를 바꿔준다.

                                  1, 3, 5, 4, 2

이제 5와 4를 비교하여 자리를 바꿔 준다.

                                  1, 3, 4, 5, 2

마지막으로 5와 2를 비교하여 자리를 바꿔준다.

                                  1, 3, 4, 2, 5

같은 방식으로 오름차순 정렬이 될때까지 반복해준다.
단, 회차가 거듭될수록 이미 정렬된 값을 제외하고 비교하므로, 비교할 숫자의 개수는 줄아든다.

```java

class BubbleSort {
    public static void main(String[] args) {
        int[] arr = new int[]{1, 5, 3, 4, 2};

        for (int i = arr.length; i > 0; i--) {
            for (int j = 0; j < i-1; j++) {
                if (arr[j] > arr[j+1]) {
                    int temp = arr[j+1];
                    arr[j+1] = arr[j];
                    arr[j] = temp;
                }
            }
        }
        for (int ar : arr) {
            System.out.println(ar);
        }
    }
}
```

## 선택 정렬(Selection Sort)

선택 정렬은 주어진 숫자들 중 가장 작은 값을 찾아 맨 앞으로 옮기고, 
정렬된 자리를 제외한 숫자들 중에 가장 작은 값을 찾아 맨 앞으로 옮겨준다. 
이를 반복하여 정렬하는 방법으로 버블정렬과 유사하며 시간복잡도 또한 O(n^2) 으로 버블정렬과 유사하다.

예를 들어

                                  3, 5, 2, 4, 1 

5개의 숫자를 오름차순으로 정렬하는 경우, 3과 5를 비교하면 3이 더 작기 때문에 자리를 옮기지 않는다. 

그 다음으론 3와 2을 비교한다. 2가 더 작지만 뒤에 더 작은 값이 있을 수 있기 때문에 비교를 계속한다.
단, 이때부터는 2와 다른 값을 비교한다.

2와 4를 비교하면 2가 더 작기 때문에 다음값으로 넘어간다.

2와 1을 비교하면 1이 더 작고 더 이상 비교할 값이 없기 때문에 1과 3의 자리를 바꿔준다.

                                  1, 5, 2, 4, 3

다음으로는 5의 자리에 올 가장 작은 수를 찾아서 동일한 방법으로 정렬한다.
모든 숫자가 오름차순이 정렬될 때까지 반복해준다.

```java

class SelectionSort {
    public static void main(String[] args) {
        int[] arr = new int[]{1, 5, 3, 4, 2};

        for (int i = 0; i < arr.length; i++) {
            int idx = i;
            for (int j = i; j < arr.length-1; j++) {
                if (arr[idx] > arr[j+1]) {
                    idx = j+1;
                }
            }
            int temp = arr[idx];
            arr[idx] = arr[i];
            arr[i] = temp;
        }
        for (int ar : arr) {
            System.out.println(ar);
        }
    }
}


```

## 삽입 정렬(Insertion Sort)

삽입 정렬은 가장 작은 범위로 시작하여 범위를 늘려가며 정렬하는 방법이다. 
O(n^2) 의 시간복잡도를 가지지만, 정렬이 되어있는 경우에는 시간 복잡도가 O(n) 이 된다.

예를 들어

                                  3, 5, 2, 4, 1 

5개의 숫자를 오름차순 정렬하는 경우, 먼저 5까지만 정렬을 진행한다.

3과 5가 오름차순으로 정렬되어 있기 때문에, 범위를 늘려서 2까지 정렬을 진행한다.

앞에서 3과 5를 오름차순 정렬했기 때문에 2만 정렬하면 된다. 

2와 5를 비교하여 자리를 바꿔준다.

                                  3, 2, 5, 4, 1

다음으론 3과 2를 비교하여 자리를 바꿔준다.

                                  2, 3, 5, 4, 1

이와 같은 방식으로 범위를 늘려가며 오름차순 정렬을 진행한다.

```java

class InsertionSort {
    public static void main(String[] args) {
        int[] arr = new int[]{1, 5, 3, 4, 2};

        for (int i = 1; i < arr.length; i++) {
            for (int j = i; j > 0; j--) {
                if (arr[j] < arr[j-1]) {
                    int temp = arr[j];
                    arr[j] = arr[j-1];
                    arr[j-1] = temp;
                } else {
                    break;
                }
            }
        }
        for (int ar : arr) {
            System.out.println(ar);
        }
    }
}


```


## 병합 정렬(Merge Sort)

## 퀵 정렬(Quick Sort)

## 힙 정렬(Heap Sort)